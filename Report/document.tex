\documentclass{bioinfo}

\usepackage{listings}
\usepackage{comment}
\usepackage{bchart}

\copyrightyear{2015}
\pubyear{2015}

\begin{document}
\firstpage{1}

\title[General Patterns]{General Patterns}
\author[Aleksejs Voroncovs \textit{and} Andreas Eichner]{Aleksejs Voroncovs\,$^{1}$ and Andreas Eichner\,$^{1}$ }%\footnote{to whom correspondence should be addressed}}
\address{$^{1}$Department of Computer Science, Boltzmannstr. 2, 85748 Garching}

\history{}%Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: Guy Yachdav}

\maketitle

\begin{abstract}

\section{Motivation:}
JavaScript is one of the most popular and rapidly developing programming languages nowadays. Therefore good coding habits in JavaScript become an important issue, considering that more and more systems use this technology. In this seminar topic the usage of general patterns and avoiding anti-patterns was studied.


\end{abstract}

%-------------------------------------Introduction---------------------------------------
\section{Introduction}
A pattern in general is a reusable solution that can be applied to commonly occurring problems in the process of development - in this case - in developing JavaScript-powered programs. Although there are various frameworks and libraries built upon the JavaScript language, this papers topic does not consider any particular of them. General patterns are those which can be used in any JavaScript project regardless of the application context.

%-------------------------------------Approach---------------------------------------
\section{Approach}

In order to demonstrate the application of general JavaScript patterns several projects on GitHub have been reviewed (see Section \ref{furread}). In each project some code parts have been optimized by applying one or multiple patterns or by getting rid of anti-patterns.

\begin{methods}

%-------------------------------------General Patterns---------------------------------------
\section{General patterns}
There are multiple universal patterns that can be applied in any JavaScript project. In this paper the following (anti-)patterns are reviewed [\citealp{chuan}]:
\begin{itemize}
\item \textit{Function declarations} - creating anonymous functions and assigning them to a variable
\item \textit{Conditionals} - patterns and anti-pattern of using if else
\item \textit{Access to the global object} - accessing the global object without hard-coding the identifier window
\item \textit{Single var pattern} - one var statement for declaring multiple variables
\item \textit{Hoisting} - moving declarations to the top of the scope
\item \textit{For loops} - optimizing for loops
\item \textit{(Not) Augmenting built-in prototypes} - anti-pattern for introducing new functionality
\item \textit{Switch pattern} - pattern for using switch-case statements correctly
\item \textit{Implied typecasting} - anti-pattern for comparing objects
\item \textit{Avoiding eval()}
\item \textit{Number conversions with parseInt()} - pattern for using parseInt function
\item \textit{Avoiding setInterval()}
\end{itemize}
All of the (anti-)patterns from the list above are presented in this paper. However, not all of them were found in the refactored projects from GitHub (see Section \ref{furread}). This section is going to cover the anti-patterns and suitable places to apply patterns that were encountered in the reviewed GitHub projects.\\

\subsection{Function declarations}
The declaration of functions in JavaScript can be done in various ways. Firstly a function can be declared anonymously:
\begin{lstlisting}
function getData() {
    ...
}
\end{lstlisting}
This approach of declaring functions can be optimized, for example by assigning the function to a variable. This enables to understand functions as an object, and enforces a semicolon after the statement. 
\begin{lstlisting}
var getData = function () {
    ...
};
\end{lstlisting}
Furthermore, this approach hides the function from the global scope.
But there is more to optimize about this approach.\\
In order to ease the stack inspection the function can provide the debugger a name. Also it allows recursive calls, since the function can call itself.
\begin{lstlisting}
var getData = function getData () {
    ...
};
\end{lstlisting}
But as mentioned by J. [\citealp{resig}], there is a danger to break the Internet Explorer by the given approach due to the same name of the function and the variable. This confuses Coffeescript and there is already an official issue reported: https://github.com/jashkenas/coffee-script/issues/366 \\
To prevent this issue from happening, the following approach can be used:
\begin{lstlisting}
var getData = function getDataF () {
    ...
};
\end{lstlisting}
All the advantages described above are included in this final approach and it neither does break any browser nor does it confuse developers, because using the variable definitely differs from calling the function.
\newpage
\subsection{Conditionals}

Conditionals are the ability to test a variable against a value and act appropriately in case the condition is met by the variable or not. They are also commonly called if-else statements by programmers.
\begin{lstlisting}
if (type === 'foo' || type === 'bar') {
    ...
}
\end{lstlisting}
As stated [\citealp{irish02}] the if statement above (normal pattern) is only an antipattern when optimizing for low-bandwidth source (such as for a bookmarklet).\\
In this case one alternative is using regular expressions:
\begin{lstlisting}
if (/^(foo|bar)\$/.test(type)) {
...
}
\end{lstlisting}
But using the normal pattern will generally outperform the regular expression in a loop.\\[0.2cm]
Another alternative for low-bandwidth cases is the object literal:
\begin{lstlisting}
if (({foo:1, bar:1})[type]) {
...
}
\end{lstlisting}
But the normal pattern is faster than the object literal for lower numbers of conditions, they generally even out around 10 conditions [\citealp{bynens}]. 


\subsection{Access to the global object}

Some parts of the code in the refactored projects contained the access to global objects with hard-coding the identifier 'window'. The refactored version of the code does not contain the explicit access to the 'window' object. Accessing the global object 'window' explicitly makes the code less portable and more dependent on the environment [\citealp{stoyan02}]. If the global object has a different name in some other environment that the project is going to be moved to, then the code which accesses the 'window' object is not going to work properly. As long as the aim of the refactoring was not to migrate the project to other environments, the 'window' identifier was just removed from the code base. The logic did not break because all objects that are accessible through the 'window' identifier are global and can be accessed without any prefix.

\subsection{Single var pattern}

Often it appears that, e.g. a function, needs multiple local variables. In order to keep the code clean, all variable declarations (for the same scope) should be at the same place. This prevents logical errors when a variable is used before it is defined. Furthermore, it helps remembering to declare variables and therefore minimizes globals.
\begin{lstlisting}
function func() {
    var a = 1;
    var b = 2;
    var sum = a + b;
    var myobject = {};
    var i;
    var j;
}
\end{lstlisting}
But once again, to increase the readability and reduce future mistakes while writing code, 
one var statement should be used to declare multiple variables:
\begin{lstlisting}
function func() {
    var a = 1
    , b = 2
    , sum = a + b
    , myobject = {}
    , i
    , j;
}
\end{lstlisting}
To reduce mistakes while extending the single var statement, the commas should be at the beginning of the line, so that the programmer will not forget to add one when adding a new variable to the end of list.

\subsection{Hoisting}
As already mentioned, variable declarations should be made as early as possible, and preferably at the same place. Otherwise, several unexpected behaviours could appear.

\begin{lstlisting}
myVar = "global"; // global variable
function func() {
	alert(myVar); // "undefined"
	var myVar = "local";
	alert(myVar); // "local"
}
func();
\end{lstlisting}
In the preceding code snippet output of the first alert statement might appear not intuitive, since the global variable \texttt{myVar} is being initialized once again in the function. JavaScript manages to declare variables at the very beginning of functions, even though they might be assigned a value at a later point [\citealp{stoyan01}].\\
Basically the behaviour of this code snippet is the same as the behaviour of the next one:
\begin{lstlisting}
myVar = "global"; // global variable
function func() {
	var myVar;
	alert(myVar); // "undefined"
	myVar = "local";
	alert(myVar); // "local"
}
func();
\end{lstlisting}
To avoid confusing any programmer, who will read over this code, it is always good, to write the code so that it seems, that the creator knew what he was doing.\\
In the example above, the early declaration of \texttt{myVar} in the function states that the first alert statement is meant to print "undefined".

\subsection{Optimized for loops}

One of the refactored projects had to do a lot with visualization and therefore contained many for loops which were necessary to perform the logic of the graphical behavior. Some of the loops were performing the array traversal and were organized in such a way that on each iteration the length of the array should have been looked up. The following code sample gives an example of this situation:
\begin{lstlisting}
for (var c = 0; c < aAddressComp.length; c ++) {
    //...
};
\end{lstlisting}
The pattern of traversing the arrays in a for loop makes use of caching the array length value to a variable. This reduces its lookup time on every iteration [\citealp{crockford}]. The experiments also show that the caching saves the running time.
\begin{lstlisting}
//Option 1
for(var i = 0; i < arr.length; i++){
	arr[i] *= 2;
}
//Option 2
for(var i = 0, len = arr.length; i < len; i++){
	arr[i] *= 2;
}
\end{lstlisting}
Both loops with an array containing one million entries were tested in the Chromium web-browser.\\
\begin{center}
\begin{bchart}[step=1,max=15,width=7cm]
  \bcbar[text=Option 1]{14.3}
    \smallskip
  \bcbar[text=Option 2]{10.2}
  \bcxlabel{Time (ms)}
\end{bchart}\\
\textit{Figure 1 - For-loop Performance}
\end{center}
As shown in the figure above, the first loop ends in 14.3 milliseconds whereas the second one in 10.2 seconds.

\subsection{(Not) Augmenting Built-in Prototypes}
In the general case enhancing the prototypes of objects that are built into the JavaScript is an anti-pattern. The following sample shows an example of augmenting the object's 'Object' prototype.
\begin{lstlisting}
Object.prototype.myMethod = function () {
    ...
};
\end{lstlisting}
The code in the project where this is done becomes less maintainable and predictable. This happens because the initial built-in object prototypes are not supposed to have such functionality and other developers may not be aware of that.
However, it is still possible to augment built-in prototypes if one is sure about any of the following conditions:
\begin{itemize}
	\item It is expected that such a feature will be implemented in future JavaScript versions
	\item It is being checked whether this custom property or method does not already exist
	\item This feature is clearly documented and communicated with the team
\end{itemize}

\subsection{Switch pattern}

The switch statement is an alternative to the conditionals. They are commonly used if the number of possible cases is reasonable.\\
The advantage over conditionals is the increased readability. If the following style conventions were considered the programmer can easily see all the cases and the statements, which will be executed then.\\[0.2cm]
Style conventions:
\begin{enumerate}
\item Align each \texttt{case}.
\item Indent the code within each case.
\item End each \texttt{case} with a clear \texttt{break}.
\item Avoid fall-throughs (when the \texttt{break} is omitted intentionally). In this case document the intention.
\item End the \texttt{switch} with a \texttt{default} to make sure there is always a sane result even if none of the cases matched.
\end{enumerate}
The following example shows how a switch statement looks like, if all the conventions above are considered:
\begin{lstlisting}
switch (expression) {
    case match1:
        result = "one";
        break;
    case match2:
        result = "two";
        break;
    ...
    default:
        result = "unknown";
}
\end{lstlisting}
\texttt{expression} can be of any type. The important thing, is that it will be compared to the matches (\texttt{match1}, \texttt{match2}, ...) behind every \texttt{case}. \\
If that expression matches one of those cases, the statements behind the case will be executed.
Otherwise the statements behind \texttt{default} will be executed.

\subsection{Implied typecasting}
Implicit data type conversion is done by the JavaScript compiler if two objects are compared with two equal signs. There are several rules how the type conversion is done in case when the types of operands differ. 
\begin{itemize}
	\item If the type of one operand is either null or undefined, then return true only if the other operand value is either null or undefined.
	\item If one of the operands is of type Boolean or Number, then convert the other operand to Number and compare.
	\item If one of the operands is an Object and the other is a primitive, then perform Object-to-Primitive conversion on the Object and compare.
\end{itemize}
To avoid implied typecasting three '=' signs should be used when comparing two objects.

\subsection{Avoiding eval()}
Using the eval() function is an anti-pattern because it complicates the debugging process, introduces the risk of injection attacks and prevents the code interpreter from runtime optimizations, for example, caching the return value of a function [\citealp{crockford}]. If the code passed to the eval() is known beforehand (not determined at runtime) then it makes no sense to use eval(). If the code that is going to be passed to eval() is generated dynamically at runtime, then eval() can be used only if there is no other option.

\subsection{Specifying the number base in parseInt}

When using the parseInt() function which parses an integer value from a given string it is important to specify the radix parameter. The logic of the program might be broken if for some reason JavaScript interprets the passed string in a different base than desired. In one of the refactored projects the following code line was present:
\begin{lstlisting}
var counter = parseInt(element.innerHTML) + 1;
\end{lstlisting}
In order to preserve the correct functioning of the program the second parameter 10 was specified in the refactored version.
\end{methods}

\subsection{Avoiding setInterval}

Using the function setInterval provided by JavaScript is in the general case an anti-pattern mainly because the program might lose the control over the order of function calls. The setInterval takes the second parameter which stands for the frequency of the function calls and executes the first parameter function every time the specified amount of milliseconds passes. This could raise problems especially if the result of the previous function call is important for the next one [\citealp{irish01}]. The general pattern to overcome this issue is to use setTimeout inside a self-calling function between the iterations. The code sample from the refactored project using this pattern looks as follows:
\begin{lstlisting}
(function updateCanvas(){
    update();
    setTimeout(updateCanvas, 
               frecUpdateCanvas);
})();
\end{lstlisting}
In this example a self-calling function invokes itself recursively after making a pause once the update() function is done. Of course, this approach has a little different logic than the setInterval function, but in most cases it is not crucial whether to wait after each iteration is done or to stick to the certain frequency of function calls. Moreover, this pattern ensures that there is no clash with repeating function calls.

%-------------------------------------Conclusion---------------------------------------
\section{Conclusion}

Nowadays JavaScript is a very common language and a high percentage of the companies include Javascript in their projects. Therefore it is almost a must for any programmer to know the basics and concepts of JavaScript. General Patterns described in this paper help producing readable and maintainable source code. \\
This should be a major goal while writing any JavaScript program, since the projects containing JavaScript are written/read by more than one programmer. Therefore the efficiency of multiple programmers is increased, as they are used to the same patterns and styles while writing code.\\
In several cases - as for example loops - even the performance can be increased.
Therefore, those patterns can be considered as guidelines for any JavaScript program.\\[0.2cm]

%-------------------------------------Further Reading---------------------------------------
\section{Further Reading}
\label{furread}
These general patterns appear in many projects, even though they are simple to realise. To show this - in addition to writing this article - the authors refactored four open source projects regarding general patterns. Those projects are listed below:
\begin{itemize}
\item CAC-Visit-Location \textit{[\citealp{francisco}]}
\item Stockwatch \textit{[\citealp{gronlund}]}
\item Webgl\_tumblr \textit{[\citealp{obuchi}]}
\item Gist-embed \textit{[\citealp{vanderhoof}]}
\end{itemize}
The refactored files can be seen in the authors GitHub project:
https://github.com/alex-vo/seminarJS.git

%\bibliographystyle{natbib}
%\bibliographystyle{achemnat}
%\bibliographystyle{plainnat}
%\bibliographystyle{abbrv}
%\bibliographystyle{plain}

%-------------------------------------References---------------------------------------
\begin{thebibliography}{}

\bibitem[Bynens, 2010]{bynens} Bynens M. (2010) Article title, {\it JavaScript performance playground} URL, https://jsperf.com

\bibitem[Chuan, 2015]{chuan} Chuan S. (2015) Article title, {\it JavaScript Patterns Collection} URL, http://shichuan.github.io/javascript-patterns/

\bibitem[Crockford, 2008]{crockford} Crockford D. (2008) Book title, {\it JavaScript: The Good Parts} ISBN, 978-0-596-51774-8

\bibitem[Irish, 2010]{irish01} Irish P. (2010) {\it 10 Things I Learned From the jQuery Source} URL, http://www.paulirish.com/2010/10-things-i-learned-from-the-jquery-source/

\bibitem[Irish, 2009]{irish02} Irish P. (2009) Article title, {jQuery Anti-Patterns for Performance} URL, http://paulirish.com/2009/perf/

\bibitem[Resig, 2011]{resig} Resig J. (2011) Article title, {\it JavaScript as a First Language} URL, http://ejohn.org/blog/javascript-as-a-first-language/

\bibitem[Stoyan, 2011]{stoyan01} Stoyan S. (2011) Article title, {\it The Essentials of Writing High Quality JavaScript} URL, http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/

\bibitem[Stoyan, 2010]{stoyan02} Stoyan S. (2010) Book title, {\it JavaScript Patterns} ISBN, 978-0596806750

%\begin{comment}
\bibitem[Francisco, 2014]{francisco} Francisco I. (2014) Repository title, {\it CAC-Visit-Location} URL, https://github.com/iagfmono/CAC-Visit-Location

\bibitem[Gronlund, 2015]{gronlund} Gronlund E. (2015) Repository title, {\it Stockwatch} URL, https://github.com/ErikGronlund/stockwatch

\bibitem[Obuchi, 2014]{obuchi} Obuchi Y. (2014) Repository title, {\it Webgl\_tumblr} URL, https://github.com/FMS-Cat/webgl\_tumblr

\bibitem[Vanderhoof, 2015]{vanderhoof} Vanderhoof B. (2015) Repository title, {\it Gist-embed} URL, https://github.com/blairvanderhoof/gist-embed
%\begin{comment}

\end{thebibliography}
\end{document}
